# -*- coding: utf-8 -*-
"""ChordTranspose.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GKUEGwXYqq2jRAKSUHoySKZ55aOLHRXy

## Chord Transpose >< Uniform Triadic Transformation (by Dennis Widjaja)

In this Colab, I create a program for chord transposition using **Uniform Triadic Transformation (UTT)**. The main idea comes from the cyclic group (part of group theory, branch of Algebra in pure mathematics) which an element of a group can generate other elements in simply transitive UTT group. 

Note that the chord are available only for major and minor chords. If you have any suggestions, feel free to send me a message.

Follow me on [GitHub](https://github.com/denniswdj) and let's connect through [LinkedIn](https://www.linkedin.com/in/dennis-w-21997a80/) !


---


Main reference:

> Hook, Julian. “Uniform Triadic Transformations.” Journal of Music Theory, vol. 46, no. 1/2, 2002, pp. 57–126. JSTOR, www.jstor.org/stable/4147678. Accessed 18 May 2021.

###Import packages needed
"""

from random import randint
import numpy as np

"""###Define function"""

def composition(a,b,c,d,e,f): #<\sigma,r_1,r_2> <\sigma*,r_1*,r_2*>
  if a == 0:
    z2 = (b + e) % 12
    z3 = (c + f) % 12
  else:
    z2 = (b + f) % 12
    z3 = (c + e) % 12

  z1 = (a + d) % 2
  return z1,z2,z3

def UTTransformation(a,b,c,d,e): #<\sigma_U,r_1,r_2> (r,\sigma)
  if e == 0:
    r = (d + b) % 12
  else:
    r = (d + c) % 12
  
  if a == 0:
    sigma = e
  else:
    sigma = (e + 1) % 2
  
  return r,sigma

def numberChord(x):
  if len(x) == 3:
    sigma = 1
    chord_simple = x[0:2]
  elif len(x) == 2:
    if x[1:2] == 'm':
      sigma = 1
      chord_simple = x[0:1]
    else:
      sigma = 0
      chord_simple = x
  else:
    sigma = 0
    chord_simple = x

  r = switcher.get(chord_simple, 'No chord available')
  return r,sigma

def step(rCheck,sigmaCheck,UTT_Triad):
  for i in range(24):
    if rCheck == UTT_Triad[i,3]:
      if sigmaCheck == UTT_Triad[i,4]:
        break
  return i

def alphabetChord(r,sigma):
  if sigma == 1:
    text2 = 'm'
  else:
    text2 = ''
  text1 = switcher_inverse.get(r, 'No chord available')
  return text1 + text2

switcher = {
      'C'   : 0, 'C#'  : 1, 'Db'  : 1, 'D'   : 2, 'D#'  : 3, 'Eb'  : 3, 'E'   : 4, 'F'   : 5, 'F#'  : 6, 'Gb'  : 6,
      'G'   : 7, 'G#'  : 8, 'Ab'  : 8, 'A'   : 9, 'A#'  : 10,'Bb'  : 10,'B'   : 11
  }

switcher_inverse = {y:x for (x,y) in switcher.items()}

"""###Pre-processing"""

m = 0 ; n = 0

while (m + n)%12 != 1 and (m + n)%12 != 5 and (m + n)%12 != 7 and (m + n)%12 != 11:
  m = randint(0,12)
  n = randint(0,12)
print("UTT Generator: <-," + str(m) + "," + str(n) + ">")

i = 1 ; j = 2
UTT_Triad = np.empty((0,3),int)
UTT_Triad = np.append(UTT_Triad, np.array([[1,m,n]]),axis=0)
while UTT_Triad[i-1,0] != 0 or UTT_Triad[i-1,1] != 0 or UTT_Triad[i-1,2] != 0:
  z1,z2,z3 = composition(UTT_Triad[j-2,0],UTT_Triad[j-2,1],UTT_Triad[j-2,2],UTT_Triad[0,0],UTT_Triad[0,1],UTT_Triad[0,2])
  i += 1
  UTT_Triad = np.append(UTT_Triad, np.array([[z1,z2,z3]]),axis=0)
  j += 1

r_matrix = []
sigma_matrix = []
for x in range(i):
  r,sigma = UTTransformation(UTT_Triad[x,0],UTT_Triad[x,1],UTT_Triad[x,2],0,0)
  r_matrix += [r]
  sigma_matrix += [sigma]

UTT_Triad = np.append(UTT_Triad, np.transpose(np.vstack((r_matrix,sigma_matrix))),axis=1)

"""###Main program"""

initialBasicTone = input("Please input your initial basic tone: ")
chordSequence = input("Please input your chord sequence (end with chord, not space " "): ")
targetBasicTone = input("Please input your target basic tone: ")
chordList = chordSequence.split(" ")
r_initial, sigma_initial = numberChord(initialBasicTone)
r_target, sigma_target = numberChord(targetBasicTone)

NoSteps = (step(r_target,sigma_target,UTT_Triad) - step(r_initial,sigma_initial,UTT_Triad)) % 24

chordListNumber = np.empty((0,2),int)
initialPosition = []
targetPosition = []
for i in range(len(chordList)):
  chord = chordList[i]
  r, sigma = numberChord(chord)
  chordListNumber = np.append(chordListNumber, np.array([[r,sigma]]),axis=0)
  k = step(chordListNumber[i,0],chordListNumber[i,1],UTT_Triad)
  initialPosition += [k]
  k = (k + NoSteps) % 24
  if k == 0:
    k = 24
  targetPosition += [k]

chordResult = []
for i in range(len(chordList)):
  r = UTT_Triad[targetPosition[i],3]
  sigma = UTT_Triad[targetPosition[i],4]
  text = alphabetChord(r,sigma)
  chordResult += [text]

FinalText = ""
for i in range(len(chordResult)): 
  FinalText = FinalText + chordResult[i] + " "
print("Transposition result: " + FinalText)